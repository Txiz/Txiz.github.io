<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">初探 Java 泛型 | 闲思笔记</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://txiz.top/Java/初探/初探 Java 泛型"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="初探 Java 泛型 | 闲思笔记"><meta data-react-helmet="true" name="description" content="初探 Java 系列第五篇，介绍 Java 中的泛型。"><meta data-react-helmet="true" property="og:description" content="初探 Java 系列第五篇，介绍 Java 中的泛型。"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://txiz.top/Java/初探/初探 Java 泛型"><link data-react-helmet="true" rel="alternate" href="https://txiz.top/Java/初探/初探 Java 泛型" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://txiz.top/Java/初探/初探 Java 泛型" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c4a0f761.css">
<link rel="preload" href="/assets/js/runtime~main.4f9b11ed.js" as="script">
<link rel="preload" href="/assets/js/main.83634378.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title">闲思笔记</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/指南">指南</a><a class="navbar__item navbar__link" href="/ComputerBasic/导航">计算机基础</a><a class="navbar__item navbar__link navbar__link--active" href="/Java/导航">Java</a><a class="navbar__item navbar__link" href="/Database/导航">数据库</a><a href="https://github.com/Txiz/Txiz.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Java/导航">导航</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active menuLinkText_OKON">初探</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 基础">初探 Java 基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 面向对象">初探 Java 面向对象</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 虚拟机">初探 Java 虚拟机</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 反射">初探 Java 反射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Java/初探/初探 Java 泛型">初探 Java 泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 注解">初探 Java 注解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 集合">初探 Java 集合</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 并发">初探 Java 并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java IO">初探 Java IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 异常">初探 Java 异常</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menuLinkText_OKON">再探</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/再探/再探 Java 基础">再探 Java 基础</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>初探 Java 泛型</h1></header><p><strong>初探 Java 系列第五篇</strong>，介绍 Java 中的泛型。</p><p>推荐先阅读初探 Java 系列的前四篇。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-中泛型的基本使用"><strong>Java 中泛型的基本使用</strong><a aria-hidden="true" class="hash-link" href="#java-中泛型的基本使用" title="Direct link to heading">​</a></h2><p>面向对象的一个重要目标的是对代码重用的支持。支持这个目标的一个重要的机制就是泛型机制（generic mechanism）：即如果一个功能除去对象的类型外，实现方式是相同的，那么就可以用泛型实现（generic implementation）来描述这个功能。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-5-之前用继承来实现泛型程序设计">Java 5 之前用继承来实现泛型程序设计<a aria-hidden="true" class="hash-link" href="#java-5-之前用继承来实现泛型程序设计" title="Direct link to heading">​</a></h3><p>与许多程序设计语言（例如 C++，它使用模板来实现泛型编程）不同，在 Java 5 之前，Java 并不支持泛型实现，泛型的实现其实是通过使用继承的一些基本概念来完成的。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>Sun 公司是在 2001 年把对泛型方法和类的直接支持作为未来的语言增强剂来宣布的，然后直到 2004 年末发表了 Java 5 并提供了对泛型方法和类的支持。</p></div></div><p>使用泛型类需要理解在 Java 5 之前对泛型编程的语言特性，因此对与如何使用继承来实现泛型程序的理解是至关重要的。而在 Java 中，基本思想就是使用像 Object 这样适当的超类来实现泛型类。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain"> * 一个简单的线性表</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class MyArrayList {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  </span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  // Object 数组用于存放线性表中的元素</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private Object[] elementData;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  // 从数组中获取元素和添加元素</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public Object get(int i) { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void add(Object o) { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面这个简单的线性表的实现就是如何用继承来实现泛型程序设计的一个简单实例，这种是实现方式有两个最基本的问题。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>注意这里的描述带了基本两个字，就是说这两个问题是最浅显容易想到的，其实这种实现方式还存在着别的问题，以后会逐一介绍到。</p></div></div><p>第一个问题是：当我们试图获取一个值的时候，必须进行强制类型转换。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">MyArrayList list = new MyArrayList();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">list.add(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">String str = (String) list.get(0);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>第二个问题是：可以向线性表中添加不同类的对象。对于这个调用，编译和运行都不会有问题，但是如果调用 get() 方法并将结果强制转换成 String类型，就会产生错误。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">MyArrayList list = new MyArrayList();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">list.add(&quot;Hello World&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">list.add(new File(&quot;文件路径&quot;));</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-泛型机制使用类型参数来指示元素的类型">Java 泛型机制使用类型参数来指示元素的类型<a aria-hidden="true" class="hash-link" href="#java-泛型机制使用类型参数来指示元素的类型" title="Direct link to heading">​</a></h3><p>Java 泛型机制使用类型参数（type parameters）来指示元素的类型，类型参数能够解决上述例子中出现的两个问题。</p><p>例如声明一个线性表的例子。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里又出现了一个很不简洁地方：既然 list 这个对象已经是 <code>List&lt;String&gt;</code> 类型的对象了，那么等号右边的 ArrayList 的类型参数也必然是 String，其他类型的参数都会产生编译错误。</p><p>所以在 Java 7 之后，增加了一种新的语言特性，叫做菱形运算符 <code>&lt;&gt;</code>，使得代码可以进一步简化。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="如何定义一个简单的泛型类">如何定义一个简单的泛型类<a aria-hidden="true" class="hash-link" href="#如何定义一个简单的泛型类" title="Direct link to heading">​</a></h3><p>一个泛型类（generic class）就是具有一个或者多个类型变量的类。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T first;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T second;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  </span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public T getFirst() { return first; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public T getSecond() { return second; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setFirst(T newValue) { first = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(T newValue) { second = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Pair 类引入了一个类型 T，但其实泛型类可以有多个类型变量。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Pair&lt;T, U&gt; { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span><strong>类型描述符</strong></h5></div><div class="admonition-content"><p>类型描述符一般是使用大写形式，而且比较短，最好是一个字母。在 Java 库中，往往使用变量 E 表示集合的元素类型，K 和 V 分别表示关键字和值的类型。T（不够的话可以用邻近的字母 U 和 S）表示任意类型。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="如何使用一个简单的泛型方法">如何使用一个简单的泛型方法<a aria-hidden="true" class="hash-link" href="#如何使用一个简单的泛型方法" title="Direct link to heading">​</a></h3><p>泛型除了用来定义泛型类，还可以定义一个带有类型参数的方法。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Generic {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public static &lt;T&gt; T getMiddle(T... a){</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return a[a.length / 2];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">} </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>getMiddle(T...) 这个方法是定义在一个普通类里面的，然而这是一个泛型方法，类型参数放在方法修饰符（public static）后面，返回类型的前面。</p><p>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String result = Generic.&lt;String&gt;getMiddle(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>实际上在大多数情况下，方法调用可以省略类型参数，只要编译器有足够的信息就能够推断出所调用的方法的类型。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String result = Generic.getMiddle(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>几乎在大多数情况下，方法调用中都可以省略类型参数，也不会出现什么问题。但是也有情况下会出现错误，比如下面这个例子。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String result = Generic.getMiddle(3.14, 1000, 0);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>为什么会出错呢，因为首先编译器会把 3 个参数自动装箱成对应的包装类对象：也就是 1 个 Double 对象和 2 个 Integer 对象，然后寻找这两个类的共同的超类型。这并没有什么问题，有问题的是这两个类有两个共同的超类型：Number 和 Comparable，那么编译器将无法推断。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>对于这种情况，一个比较好的解决办法就是把三个参数都写成 double 值。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="使用-extends-来限定类型变量">使用 extends 来限定类型变量<a aria-hidden="true" class="hash-link" href="#使用-extends-来限定类型变量" title="Direct link to heading">​</a></h3><p>先来看一段代码。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Generic {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public static &lt;T&gt; T min(T[] a) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (a == null || a.length == 0) return null;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    T smallest = a[0];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    for (int i = 1; i &lt; a.length; i++) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      if(smallest.compareTo(a[i]) &gt; 0) smallest = a[i];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return smallest;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>仔细看一下这段代码，会注意到一个问题，对于随便的一个类型 T，T 类型一定会有 compareTo 方法吗？</p><p>当然这种写法下是无法保证 T 类型一定会有 compareTo 方法的，为了解决这个问题，只需要将 T 限制为实现了 Comparable 接口的类就行。可以通过对类型变量 T 设置限定实现这一点。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>Comparable 接口是只含一个方法 compareTo 的标准接口。</p></div></div><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Generic {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public static &lt;T extends Comparable&gt; T min(T[] a) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (a == null || a.length == 0) return null;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    T smallest = a[0];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    for (int i = 1; i &lt; a.length; i++) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      if(smallest.compareTo(a[i]) &gt; 0) smallest = a[i];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return smallest;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>实际上这个写法并不是最好的，Comparable 接口本身就是一个泛型类型，但是现在暂时忽略其复杂性以及编译器产生的警告，往后会继续讨论如何更适当的适用类型参数。</p></div></div><p>一个类型变量或通配符可以有多个限定，限定类型使用 &amp; 分隔。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Generic {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public static &lt;T extends Comparable &amp; Serializable&gt; T min(T[] a) { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>可能会存在一个疑惑，在 Java 继承相关的语法里，继承一个类用 extends，实现一个接口用 implements，那么为什么在上述示例中使用的是关键字 extends 而不是 implements？从概念上讲 <code>&lt;T extends BoundingType&gt;</code> 表示 T 应该是绑定类型的子类型，T 和绑定类型可以是类，也可以是接口，选择使用 extends 的原因是更加接近子类的概念。</p></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="虚拟机没有泛型类型对象"><strong>虚拟机没有泛型类型对象</strong><a aria-hidden="true" class="hash-link" href="#虚拟机没有泛型类型对象" title="Direct link to heading">​</a></h2><p>泛型很大程度上是 Java 语言中的成分而不是虚拟机中的结构。泛型类可以由编译器通过<strong>类型擦除（type erasure）</strong>转换成非泛型类。编译器会生成一种与泛型类同名的<strong>原始类（raw class）</strong>，但是相关的类型参数都被删去了，类型变量将由它们的类型限界来代替。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>类型擦除的一个重要重要推论是，所生成的代码和在泛型之前所写的代码并没有太多的差异，而且运行的也并不快，其显著优点在于，不用将一些类型转换放到代码中，编译器将进行重要的类型检验。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="无限定的变量擦除后会用-object-进行替换">无限定的变量擦除后会用 Object 进行替换<a aria-hidden="true" class="hash-link" href="#无限定的变量擦除后会用-object-进行替换" title="Direct link to heading">​</a></h3><p>对于无限定的变量，会直接使用 Object 进行替换，下面是刚才出现过的示例泛型类 <code>Pair&lt;T&gt;</code>。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T first;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T second;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  </span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public T getFirst() { return first; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public T getSecond() { return second; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setFirst(T newValue) { first = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(T newValue) { second = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>替换后的原始类型如下。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Pair {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private Object first;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private Object second;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  </span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public Object getFirst() { return first; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public Object getSecond() { return second; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setFirst(Object newValue) { first = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(Object newValue) { second = newValue; }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到原始类其实就是一个普通的类，就好像泛型正式引入 Java 之前已经实现的那样。在程序中可以包含不同类型的 Pair，比如 <code>Pair&lt;String&gt;</code>，<code>Pair&lt;Integer&gt;</code>，类型擦除后就变成了原始的 Pair 类型了。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="存在限定时使用第一个限定的类型变量来替换">存在限定时使用第一个限定的类型变量来替换<a aria-hidden="true" class="hash-link" href="#存在限定时使用第一个限定的类型变量来替换" title="Direct link to heading">​</a></h3><p>上面已经介绍了在没有给限定的时候使用 Object 替换，比如 Pair&lt; T &gt;中没有显式的限定，所以原始类型使用 Object 替换掉了 T。假定声明了一个使用了限定的类型，那么就用限定的类型进行替换，如果声明的限定有多个时，就是用第一个限定的类型变量做替换。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Interval&lt;T extends Comparable &amp; Serializable&gt; implements Serializable {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T lower;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private T upper;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public Interval(T first, T second) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (first.compareTo(second) &lt;= 0) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      lower = first;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      upper = second;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      lower = second;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      upper = first;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>那么被替换后的原始类型如下。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Interval implements Serializable {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private Comparable lower;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  private Comparable upper;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public Interval(Comparable first, Comparable second) { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>现在考虑如果切换限定的顺序为：<code>class Interval&lt;T extends Serializable &amp; Comparable&gt;</code>，如果这样做，原始类型将使用 Serializable 替换掉 T，编译器会在必要的时候向 Comparable 插入强制类型转换。所以为了提高效率，应该将没有方法的标签接口放在限定列表的末尾（比如 Serializable，该接口内没有需要实现的方法，仅代表实现它的类可以序列化）。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="泛型方法擦除返回类型时会插入强制类型转换">泛型方法擦除返回类型时会插入强制类型转换<a aria-hidden="true" class="hash-link" href="#泛型方法擦除返回类型时会插入强制类型转换" title="Direct link to heading">​</a></h3><p>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Pair&lt;String&gt; pair = new Pair&lt;&gt;();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">pair.setFirst(&quot;Hello&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">String str = pair.getFirst();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>擦除 getFirst() 方法的返回类型后将返回 Object 类型，于是编译器将会自动插入 Employee 的强制类型转换。即第一步先调用 Pair.getFirst()，第二步将返回的 Object 类型转换为 String 类型。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="泛型方法被擦除时使用桥方法来保持多态">泛型方法被擦除时使用桥方法来保持多态<a aria-hidden="true" class="hash-link" href="#泛型方法被擦除时使用桥方法来保持多态" title="Direct link to heading">​</a></h3><p>看下面一段代码。一个 DateInterval 对象是一对 LocalDate 对象，需要覆盖 setSecond() 方法来确保第二个值永远不小于第一个值。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class DateInterval extends Pair&lt;LocalDate&gt; {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(LocalDate second) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (second.compareTo(getFirst()) &gt;= 0) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      super.setSecond(second);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>DateInterval 类擦除后会变成如下样子。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class DateInterval extends Pair {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(LocalDate second) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (second.compareTo(getFirst()) &gt;= 0) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">      super.setSecond(second);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  public void setSecond(Object second) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    setSecond((Date) second);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>有一个让人觉得很奇怪的地方，就是多了一个 setSecond() 方法，它的参数类型是 Object。这显然是一个不同的方法，因为它的类型参并不是 LocateDate，解释这个问题之前，先考虑正常情况下应该如何使用 DateInterval 这个类。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">DateInterval interval = new DateInterval( ... ); // 调用某个构造函数赋值</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">Pair&lt;LocalDate&gt; pair = interval // 向上转型</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">pair.setSecond(aDate) // 假定之前已经有一个 LocalDate 对象 aDate</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>由于 pair 引用了一个 DateInterval 对象，所以希望调用的是 DateInterval.setSecond() 方法，它的参数类型是 LocalDate，问题在于当编译器类型擦除之后，Pair 的实际类型是 Object，于是类型擦除和多态发生了冲突，要解决这个冲突，也就是需要编译器在 DateInterval 类中生成一个<strong>桥方法（bridge method）</strong>，即 DateInterval 中参数类型为 Object 的 setSecond 方法。</p><p>也就是说，变量 pair 已经被声明为类型 <code>Pair&lt;LocalDate&gt;</code>，并且这个类型有一个简单的方法叫做 setSecond()，当类型擦除后，方法会是 setSecond(Object)。虚拟机用 pair 引用的对象调用了这个方法，这个对象是 DateInterval 类型的，因而将会调用 DateInterval.setSecond(Object) 方法（但实际上没有，只有一个setSecond(LocalDate)），所以编译器会合成一个 DateInterval.setSecond(Object) 来供我们调用。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>这一块的内容，需要比较熟悉面向对象相关的知识，如果不太熟悉的话建议去看初探 Java 系列的第二篇。</p></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="如何正确的使用-java-泛型"><strong>如何正确的使用 Java 泛型</strong><a aria-hidden="true" class="hash-link" href="#如何正确的使用-java-泛型" title="Direct link to heading">​</a></h2><p>在 Java 中，类型擦除虽然使得编码得到了简化，但同样也带来的诸多限制，了解这些限制才能正确并且优雅的使用 Java 泛型。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="运行时类型查询-instanceof-只适用于原始类型">运行时类型查询 instanceof 只适用于原始类型<a aria-hidden="true" class="hash-link" href="#运行时类型查询-instanceof-只适用于原始类型" title="Direct link to heading">​</a></h3><p>简单来说，虚拟机中的对象总是有一个特定的非泛型类型，因此所有的类型查询只产生原始类型。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">if (a instanceof Pair&lt;String&gt;) { ... }  // 这个写法是错误的</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">if (a instanceof Pair&lt;T&gt;) { ... }  // 这个写法也是错误的</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="不能使用基本类型实例化类型参数">不能使用基本类型实例化类型参数<a aria-hidden="true" class="hash-link" href="#不能使用基本类型实例化类型参数" title="Direct link to heading">​</a></h3><p>泛型不能用使用基本类型实例化类型参数，应该使用基本类型的对应的包装类。因此，没有 <code>Pair&lt;double&gt;</code>，只有 <code>Pair&lt;Double&gt;</code>。这是由于类型擦除所导致的，因为类型擦除后 Pair 类是被 Object 替换的，有限定的话会使用限定替换，而 Object 不能存储 double 值。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="不能创建参数化类型的数组">不能创建参数化类型的数组<a aria-hidden="true" class="hash-link" href="#不能创建参数化类型的数组" title="Direct link to heading">​</a></h3><p>泛型不能创建参数化类型的数组。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; // 这个写法是错误的</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>因为当类型擦除后，table的类型是 Pair[]，可以把它转换成 Object[]。</p><p>然而 Java 数组会记住它的元素类型是什么，如果试图存其它的元素，就会报错，当泛型擦除后，期望数组能够继续保证元素是 Pair，但是此时数组显然无法在保证这一点（因为擦除后数组是 Object[] 了），会使这种机制无效。</p><p>在之后会介绍到通配符类型，可以声明通配类型的数组，然后进行类型转换。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这确实是一个可行的写法，但这个结果仍然不够安全，如果往 table<!-- -->[0]<!-- --> 中存入一个 <code>Pair&lt;Employee&gt;</code>，然后调用 table<!-- -->[0]<!-- -->.getFirst()，会出现类型转换的异常（因为 getFirst() 的结果是 String，无法转成 Employee ）。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>如果需要收集参数化类型对象，只有一种安全而有效的方法，就是使用：<code>ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt;</code>。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="不能实例化类型变量">不能实例化类型变量<a aria-hidden="true" class="hash-link" href="#不能实例化类型变量" title="Direct link to heading">​</a></h3><p>简单来说就是不能使用 new T()，new T[]，T.class 这样的表达式中的类型变量。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">// 这种写法是错误的</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">public Pair() {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  first = new T();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  second = new T();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>解决办法是让调用者提供一个构造器表达式。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  return new Pair&lt;&gt;(constr.get(), constr.get());</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  Pair&lt;String&gt; p = Pair.makePair(String::new);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>makePair 方法接收一个 <code>Supplier&lt;T&gt;</code>，这是一个函数式接口，表示一个无参数而且返回类型为 T 的函数。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="不能构造泛型数组">不能构造泛型数组<a aria-hidden="true" class="hash-link" href="#不能构造泛型数组" title="Direct link to heading">​</a></h3><p>既然不能实例化一个泛型实例，那自然也不能实例化数组。但是原因上有所不同，毕竟数组会填充 null 值，构造时看上去是安全的。但是由于泛型擦除，仍然会出现问题。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static &lt;T extends Comparable&gt; T[] minmax(T[] a) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  T[] mm = new T[2];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在类型擦除后，方法体中的第一行代码始终会构造 Comparable<!-- -->[2]<!-- --> 数组，而这显然不是被需要的。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="a-是-b-的子类但-paira-与-pairb-没有关系">A 是 B 的子类，但 <code>Pair&lt;A&gt;</code> 与 <code>Pair&lt;B&gt;</code> 没有关系<a aria-hidden="true" class="hash-link" href="#a-是-b-的子类但-paira-与-pairb-没有关系" title="Direct link to heading">​</a></h3><p>在使用泛型类时，需要了解一些有关继承和子类型的准则，假设 A 是 B 的子类，但是 <code>Pair&lt;A&gt;</code> 与 <code>Pair&lt;B&gt;</code> 没有关系。无论 A 和 B 有什么关系，往往 <code>Pair&lt;A&gt;</code> 和 <code>Pair&lt;B&gt;</code> 并没有什么关系。</p><img src="/assets/images/泛型类之间的关系-6d524749b607d49f0d16db6629da0620.jpg" width="500px"><p>泛型类可以扩展或实现其它的泛型类，就这一点而言，与普通的类并没有什么区别。例如，<code>ArrayList&lt;T&gt;</code> 实现了 <code>List&lt;T&gt;</code>，这意味着一个 <code>ArrayList&lt;Manager&gt;</code> 可以转换成一个 <code>List&lt;Manager&gt;</code>，但是一个 <code>ArrayList&lt;Manager&gt;</code> 不是一个 <code>ArrayList&lt;Employee&gt;</code> 或者 <code>List&lt;Employee&gt;</code>。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="通过通配符类型更优雅的使用泛型"><strong>通过通配符类型更优雅的使用泛型</strong><a aria-hidden="true" class="hash-link" href="#通过通配符类型更优雅的使用泛型" title="Direct link to heading">​</a></h2><p>固定的泛型类型系统使用起来虽然很方便，但是却并不令人愉快，由于泛型擦除的存在，泛型所带来的方便之处能否抵消由此所引起的麻烦是一个纠缠不清的问题。所以 Java 的设计者发明了一种巧妙的并且仍是安全的解决方案：<strong>通配符类型</strong>。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="通配符的子类型限定">通配符的子类型限定<a aria-hidden="true" class="hash-link" href="#通配符的子类型限定" title="Direct link to heading">​</a></h3><p>假设 Manager 是 Employee 的子类。</p><p>通配符类型中，允许类型参数变化，<code>Pair&lt;? extends Employee&gt;</code> 表示一个泛型类型 Pair，它的类型参数是 Employee 的子类。</p><p>先看下面的代码。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void printBuddies(Pair&lt;Employee&gt; p) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  Employee first = p.getFirst();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  Employee second = p.getSecond();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>按照这种写法，是不能将 <code>Pair&lt;Manager&gt;</code> 传递给这个方法的，要解决这个问题，就可以使用通配符类型。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void printBuddies(Pair&lt;? extends Employee&gt; p) { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当使用 <code>Pair&lt;? extends Employee&gt;</code> 时，先看下面的代码，然后仔细想一想。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">? extends Employee getFirst() { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">void setFirst(? extends Employee) { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>使用 <code>Pair&lt;? extends Employee&gt;</code>，其方法如上，使用 getFirst() 当然没有什么问题，将 getFirst() 的返回值赋给一个 Employee 是符合 Java 语法的。但是 setFirst() 就是无法调用的，毕竟对于方法参数，只知道需要某个 Employee 的子类型，但是却不知道具体是什么类型，它将拒绝传递任何特定的类型，毕竟 ? 不能用来匹配。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="通配符的超类型限定">通配符的超类型限定<a aria-hidden="true" class="hash-link" href="#通配符的超类型限定" title="Direct link to heading">​</a></h3><p>通配符限定和类型变量限定十分相似，但是通配符限定还有一个附加的能力，就是可以指定一个超类型限定，例如 <code>Pair&lt;? super Manager&gt;</code>。</p><p>这个通配符限制为 Manager 的所有超类型（已有的 super 关键字能够十分准确地描述这种联系，就像 extends 一样）。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">? super Employee getFirst() { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">void setFirst(? super Manager) { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>还是上面这段代码，此时情况又不同了，使用 <code>Pair&lt;? super Manager&gt;</code> 时，无法知道 setFirst() 方法的具体类型，因此调用 setFirst() 这个方法时不能接受类型为 Employee 或 Object 的参数，只能传递 Manager 类型的对象，或者某个子类型对象。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>注意这里有一点绕，<code>Pair&lt;? super Manager&gt;</code> 可以匹配 <code>Pair&lt;Employee&gt;</code> 和 <code>Pair&lt;Object&gt;</code>，但是 Pair.setFirst() 方法的参数只能接受 Manager 以及其子类型。这里需要非常清楚的理解<strong>多态中向上转型</strong>部分的知识点。</p></div></div><p>然后是调用 getFirst() 方法，不能保证返回对象的类型，只能将它赋给一个 Object。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void minmaxBonus(Manager[] a, Pair&lt;? super Manager&gt; pair) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  if (a.length == 0) return;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  Manager min = a[0];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  Manager max = a[0];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  for(int i=1; i&lt;a.length; i++) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if(min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if(max.getBonus() &lt; a[i].getBonus()) max = a[i];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  result.setFirst(min);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  result.setSecond(max);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>直观的讲，带有超类型类型的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="无限定通配符">无限定通配符<a aria-hidden="true" class="hash-link" href="#无限定通配符" title="Direct link to heading">​</a></h3><p>事实上，还可以使用无限定的通配符，例如：<code>Pair&lt;?&gt;</code>，初看起来，好像和原始的 Pair 是一样的，但是实际上有很大的不同。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">? getFirst() { ... }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">void setFirst(?) { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>getFirst() 的返回值只能被赋值给一个 Object，setFirst() 方法则不能被调用，甚至不能用 Object 调用。Pair&lt;?&gt; 和 Pair 的本质不同在于：<strong>可以用任意 Object 对象调用原始 Pair 的 setFirst() 方法</strong>。之所以要使用这样看上去毫无意义的类型，是因为它对于很多简单的操作都很有用，比如下面的这段代码。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static boolean hasNulls(Pair&lt;?&gt; p) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">  return p.getFirst() == null || p.getSecond() == null;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以使用上面的方法来测试一个 pair 是否包含一个 null 引用，它并不需要实际的类型。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Java/初探/初探 Java 反射"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->初探 Java 反射</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Java/初探/初探 Java 注解"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">初探 Java 注解<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java-中泛型的基本使用" class="table-of-contents__link toc-highlight"><strong>Java 中泛型的基本使用</strong></a><ul><li><a href="#java-5-之前用继承来实现泛型程序设计" class="table-of-contents__link toc-highlight">Java 5 之前用继承来实现泛型程序设计</a></li><li><a href="#java-泛型机制使用类型参数来指示元素的类型" class="table-of-contents__link toc-highlight">Java 泛型机制使用类型参数来指示元素的类型</a></li><li><a href="#如何定义一个简单的泛型类" class="table-of-contents__link toc-highlight">如何定义一个简单的泛型类</a></li><li><a href="#如何使用一个简单的泛型方法" class="table-of-contents__link toc-highlight">如何使用一个简单的泛型方法</a></li><li><a href="#使用-extends-来限定类型变量" class="table-of-contents__link toc-highlight">使用 extends 来限定类型变量</a></li></ul></li><li><a href="#虚拟机没有泛型类型对象" class="table-of-contents__link toc-highlight"><strong>虚拟机没有泛型类型对象</strong></a><ul><li><a href="#无限定的变量擦除后会用-object-进行替换" class="table-of-contents__link toc-highlight">无限定的变量擦除后会用 Object 进行替换</a></li><li><a href="#存在限定时使用第一个限定的类型变量来替换" class="table-of-contents__link toc-highlight">存在限定时使用第一个限定的类型变量来替换</a></li><li><a href="#泛型方法擦除返回类型时会插入强制类型转换" class="table-of-contents__link toc-highlight">泛型方法擦除返回类型时会插入强制类型转换</a></li><li><a href="#泛型方法被擦除时使用桥方法来保持多态" class="table-of-contents__link toc-highlight">泛型方法被擦除时使用桥方法来保持多态</a></li></ul></li><li><a href="#如何正确的使用-java-泛型" class="table-of-contents__link toc-highlight"><strong>如何正确的使用 Java 泛型</strong></a><ul><li><a href="#运行时类型查询-instanceof-只适用于原始类型" class="table-of-contents__link toc-highlight">运行时类型查询 instanceof 只适用于原始类型</a></li><li><a href="#不能使用基本类型实例化类型参数" class="table-of-contents__link toc-highlight">不能使用基本类型实例化类型参数</a></li><li><a href="#不能创建参数化类型的数组" class="table-of-contents__link toc-highlight">不能创建参数化类型的数组</a></li><li><a href="#不能实例化类型变量" class="table-of-contents__link toc-highlight">不能实例化类型变量</a></li><li><a href="#不能构造泛型数组" class="table-of-contents__link toc-highlight">不能构造泛型数组</a></li><li><a href="#a-是-b-的子类但-paira-与-pairb-没有关系" class="table-of-contents__link toc-highlight">A 是 B 的子类，但 <code>Pair&lt;A&gt;</code> 与 <code>Pair&lt;B&gt;</code> 没有关系</a></li></ul></li><li><a href="#通过通配符类型更优雅的使用泛型" class="table-of-contents__link toc-highlight"><strong>通过通配符类型更优雅的使用泛型</strong></a><ul><li><a href="#通配符的子类型限定" class="table-of-contents__link toc-highlight">通配符的子类型限定</a></li><li><a href="#通配符的超类型限定" class="table-of-contents__link toc-highlight">通配符的超类型限定</a></li><li><a href="#无限定通配符" class="table-of-contents__link toc-highlight">无限定通配符</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Txiz</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4f9b11ed.js"></script>
<script src="/assets/js/main.83634378.js"></script>
</body>
</html>