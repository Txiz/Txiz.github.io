<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">初探 Java 基础 | 闲思笔记</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://txiz.top/Java/初探/初探 Java 基础"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="初探 Java 基础 | 闲思笔记"><meta data-react-helmet="true" name="description" content="初探 Java 系列第一篇，本文的目的仅在于对 Java 基础部分知识点查漏补缺以及深入理解，而并非带你从零开始学习 Java，所以需要对 Java 已经有简单的了解。"><meta data-react-helmet="true" property="og:description" content="初探 Java 系列第一篇，本文的目的仅在于对 Java 基础部分知识点查漏补缺以及深入理解，而并非带你从零开始学习 Java，所以需要对 Java 已经有简单的了解。"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://txiz.top/Java/初探/初探 Java 基础"><link data-react-helmet="true" rel="alternate" href="https://txiz.top/Java/初探/初探 Java 基础" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://txiz.top/Java/初探/初探 Java 基础" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c4a0f761.css">
<link rel="preload" href="/assets/js/runtime~main.4f9b11ed.js" as="script">
<link rel="preload" href="/assets/js/main.83634378.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title">闲思笔记</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/指南">指南</a><a class="navbar__item navbar__link" href="/ComputerBasic/导航">计算机基础</a><a class="navbar__item navbar__link navbar__link--active" href="/Java/导航">Java</a><a class="navbar__item navbar__link" href="/Database/导航">数据库</a><a href="https://github.com/Txiz/Txiz.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Java/导航">导航</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active menuLinkText_OKON">初探</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Java/初探/初探 Java 基础">初探 Java 基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 面向对象">初探 Java 面向对象</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 虚拟机">初探 Java 虚拟机</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 反射">初探 Java 反射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 泛型">初探 Java 泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 注解">初探 Java 注解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 集合">初探 Java 集合</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 并发">初探 Java 并发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java IO">初探 Java IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/初探/初探 Java 异常">初探 Java 异常</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menuLinkText_OKON">再探</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Java/再探/再探 Java 基础">再探 Java 基础</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>初探 Java 基础</h1></header><p><strong>初探 Java 系列第一篇</strong>，本文的目的仅在于对 Java 基础部分知识点查漏补缺以及深入理解，而并非带你从零开始学习 Java，所以需要对 Java 已经有简单的了解。</p><p>在阅读本文之前，推荐先阅读<a href="/ComputerBasic/导航">初探计算机基础</a>系列。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-的基本概念"><strong>Java 的基本概念</strong><a aria-hidden="true" class="hash-link" href="#java-的基本概念" title="Direct link to heading">​</a></h2><p>先简单的介绍一下关于 Java 的一些基本常识。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="jvmjdkjre-都是些什么">JVM，JDK，JRE 都是些什么<a aria-hidden="true" class="hash-link" href="#jvmjdkjre-都是些什么" title="Direct link to heading">​</a></h3><p><strong>JVM</strong> 是 Java 虚拟机，用来运行 Java 字节码，JVM 有针对不同系统的特定实现（Windows，Linux，MacOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>JDK</strong> 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p><strong>JRE</strong> 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的一些基础构件。但是它不能用于创建新程序。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>如果只是为了运行一下 Java 程序的话，那么只需要安装 JRE 就可以了。如果需要进行一些 Java 编程方面的工作，那么就需要安装 JDK 了。但是这不是绝对的。有时即使不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK，这种情况往往出现于你的计算机上的其它软件需要依赖于 Java 环境。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="为什么说-java-语言是编译与解释共存">为什么说 Java 语言是“编译与解释共存”<a aria-hidden="true" class="hash-link" href="#为什么说-java-语言是编译与解释共存" title="Direct link to heading">​</a></h3><p><strong>Java 语言既具有编译型语言的特征，也具有解释型语言的特征</strong>。因为 Java 程序要经过先编译，后解释两个步骤。由 Java 编写的程序需要先经过编译步骤，生成字节码文件（<!-- -->*<!-- -->.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span><strong>编译与解释</strong></h5></div><div class="admonition-content"><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码，比如 C/C++；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行，比如 Python。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="object-类是一切的始祖">Object 类是一切的始祖<a aria-hidden="true" class="hash-link" href="#object-类是一切的始祖" title="Direct link to heading">​</a></h3><p>整个源代码五百多行，看起来很多，但其实大部分都是英文注释说明，整个 Object 类并没有多少东西。</p><p>现在至少要知道作为 Java 最核心的类之一的 Object 中到底有哪几个方法。至于它们各自的作用的详细分析，此时无需关心过多，简单了解即可，往后到了合适的地方再做补充解释。</p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>源码注释</h5></div><div class="admonition-content"><p>Object 类是整个类层次结构的根，每个类都会将 Object 作为超类，所有的对象，包括数组都会实现此类的方法。</p></div></div><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public class Object {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    private static native void registerNatives();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        registerNatives();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final native Class&lt;?&gt; getClass();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public native int hashCode();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public boolean equals(Object obj) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return (this == obj);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    protected native Object clone() throws CloneNotSupportedException;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final native void notify();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final native void notifyAll();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final native void wait(long timeout) throws InterruptedException;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final void wait(long timeout, int nanos) throws InterruptedException {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        if (timeout &lt; 0) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        if (nanos &lt; 0 || nanos &gt; 999999) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        if (nanos &gt; 0) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            timeout++;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        wait(timeout);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    public final void wait() throws InterruptedException {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        wait(0);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    protected void finalize() throws Throwable { }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="objectequalsobject-obj-在比较什么">Object.equals(Object obj) 在比较什么<a aria-hidden="true" class="hash-link" href="#objectequalsobject-obj-在比较什么" title="Direct link to heading">​</a></h3><p>直接从源码里面找到 Object.equals(Object obj)。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public boolean equals(Object obj) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return (this == obj);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>很明显，这里直接返回了 == 的结果，在 Java 中，== 是在直接比较两个 Object 对象的内存地址是否相同。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="objecthashcode-用来计算散列码">Object.hashCode() 用来计算散列码<a aria-hidden="true" class="hash-link" href="#objecthashcode-用来计算散列码" title="Direct link to heading">​</a></h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p>hashCode() 定义在 Object 类中，这意味着 Java 中的任何类都包含有 hashCode() 函数。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>虽然每个 Java 类都包含 hashCode() 函数。但是仅仅当创建<strong>某个类的散列表</strong>时，该类的 hashCode() 函数才会起作用，用来确定每一个对象在散列表中的位置，其他情况下一个类的 hashCode() 函数并没有作用。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="equals-和-hashcode-的关系">equals() 和 hashCode() 的关系<a aria-hidden="true" class="hash-link" href="#equals-和-hashcode-的关系" title="Direct link to heading">​</a></h3><p>当我们不去使用 HashSet、Hashtable、HashMap 等等这些本质是散列表数据结构的类时，该类的 hashCode() 和 equals() 没有关系。</p><p>反之则是有关系的：如果两个对象相等，那么它们的 hashCode() 返回值一定相同，即通过 equals() 比较两个对象时返回 true；但是如果两个对象 hashCode() 返回值相等，它们 equals() 返回结果并不一定相等，</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span><strong>哈希冲突</strong></h5></div><div class="admonition-content"><p>这个概念最早出现于数据结构中。简单来说，两个不同的键，它们的哈希值相等，就是哈希冲突。想要详细理解可以阅读<a href="/ComputerBasic/初探/初探数据结构">初探数据结构与算法</a></p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="-和-equals-的关系">== 和 equals() 的关系<a aria-hidden="true" class="hash-link" href="#-和-equals-的关系" title="Direct link to heading">​</a></h3><p>equals() 方法有两种使用情况。</p><p><strong>情况 1</strong>：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过 == 比较这两个对象。</p><p><strong>情况 2</strong>：类重写了 equals() 方法。一般我们都重写 equals() 方法来比较两个对象的内容相等，若它们的内容相等，则返回 true (即认为这两个对象的值相等)。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    String a = new String(&quot;ab&quot;); // a 为一个引用</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    String aa = &quot;ab&quot;; // 放在常量池中</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    String bb = &quot;ab&quot;; // 从常量池中查找</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (aa == bb) // true</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">          System.out.println(&quot;aa==bb&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (a == b) // false，非同一对象</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        System.out.println(&quot;a==b&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (a.equals(b)) // true</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        System.out.println(&quot;aEQb&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="-和--的区别">&amp; 和 &amp;&amp; 的区别<a aria-hidden="true" class="hash-link" href="#-和--的区别" title="Direct link to heading">​</a></h3><p>&amp; 运算符是按位与。即将两侧的数用二进制展开，每一位都进行与运算，最后得到的二进制数就是结果。</p><p>&amp;&amp; 运算符是逻辑与。即要求运算符左右两端的布尔值都是 true 时整个表达式的值才是 true。&amp;&amp; 又被称为短路运算，即如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="switch-的操作数可以是字符串不能是-long-和-浮点数">switch 的操作数可以是字符串，不能是 long 和 浮点数<a aria-hidden="true" class="hash-link" href="#switch-的操作数可以是字符串不能是-long-和-浮点数" title="Direct link to heading">​</a></h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String s = &quot;a&quot;;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">switch (s) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    case &quot;a&quot;:</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        System.out.println(&quot;aaa&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    case &quot;b&quot;:</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        System.out.println(&quot;bbb&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-的基本数据类型"><strong>Java 的基本数据类型</strong><a aria-hidden="true" class="hash-link" href="#java-的基本数据类型" title="Direct link to heading">​</a></h2><p>在 Java 中，一共有两大数据类型：基本数据类型（内置数据类型）、引用数据类型。</p><p>其中 Java 语言支持 8 种基本数据类型。</p><table><thead><tr><th>基本</th><th>位数</th><th>字节</th><th>默认</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolbean</td><td></td><td></td><td>false</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-没有无符号整数">Java 没有无符号整数<a aria-hidden="true" class="hash-link" href="#java-没有无符号整数" title="Direct link to heading">​</a></h3><p>是的，Java 没有无符号整数，这是和 C/C++ 不一样的地方之一。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="定义-short-s--1那么-s--s--1-和-s--1-的不同">定义 short s = 1，那么 s = s + 1 和 s += 1 的不同<a aria-hidden="true" class="hash-link" href="#定义-short-s--1那么-s--s--1-和-s--1-的不同" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">short s = 1;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">s = s + 1;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">short s = 1;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">s += 1;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>对于 s = s + 1，由于 1 是 int 类型，因此 s + 1 运算结果也是 int 类型，需要强制转换类型才能赋值给 short。</p><img src="/assets/images/s=s+1-50586c302d8c48152fb8a85e24ef25bd.jpg" width="500px"><p>对于 s += 1，可以正确的进行编译，这个语句相当于 s = (short) (s + 1)，其中有隐含的强制类型转换。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="boolean-的大小是多少">boolean 的大小是多少<a aria-hidden="true" class="hash-link" href="#boolean-的大小是多少" title="Direct link to heading">​</a></h3><p>boolean 类型的大小是没有给出精确的定义的，《Java 虚拟机规范》给出了 4 个字节，和 boolean 数组 1 个字节的定义，但是具体还要看虚拟机实现是否按照规范来，所以 1 个字节、4 个字节都是有可能的。这其实是运算效率和存储空间之间的博弈，两者都非常的重要。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>在 Java 中，整型值 int 和布尔值 boolean 之间不能进行相互转换（与 C++ 不同）。</p></div></div><img src="/assets/images/Java中boolean与int不能相互转换-e25276ef0ac20227bf1f0a54dae546d8.jpg" width="500px"><h3 class="anchor anchorWithStickyNavbar_y2LR" id="float-f--34是否是正确的">float f = 3.4，是否是正确的<a aria-hidden="true" class="hash-link" href="#float-f--34是否是正确的" title="Direct link to heading">​</a></h3><p>不正确。3.4 是双精度数，将双精度型 double 赋值给浮点型 float 属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float) 3.4; 或者写成 float f = 3.4F。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">float f =(float) 3.4;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">float f = 3.4F;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>浮点数值不适用于无法接受舍入误差的金融计算中。例如 System.out.println(2.0 - 1.1) 将打印出 0.8999999999999999，而不是我们想象的 0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数 1/10。这就好像十进制无法精确地表示分数 1/3 一样。如果在数值计算中<strong>不允许有任何舍入误差</strong>，就应该使用 BigDecimal 类。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="u0022u0022u0022分别会打印什么"><code>&quot;\u0022&quot;</code>、<code>&quot;\u0022+\u0022&quot;</code>，分别会打印什么<a aria-hidden="true" class="hash-link" href="#u0022u0022u0022分别会打印什么" title="Direct link to heading">​</a></h3><p><code>System.out.println(&quot;\u0022&quot;)</code> 会报错，因为 Unicode 转义序列会在解析代码之前得到处理。这里 <code>\u0022</code> 会被处理成一个引号，也就是三个连续的引号。</p><img src="/assets/images/Unicode转义1-bbf0f313a0fa05b638280a3ee8f74228.jpg" width="500px"><p><code>System.out.println(&quot;\u0022+\u0022&quot;)</code> 会打印一个空串，你要能搞明白上面那个问题，所以这个地方 <code>&quot;\u0022+\u0022&quot;</code> 并不是一个由引号 <code>\u0022</code> 包围加号构成的字符串。 实际上，<code>\u0022</code> 会在解析之前转换为 &quot;， 这会得到 &quot;&quot;+&quot;&quot;，也就是一个空串。</p><img src="/assets/images/Unicode转义2-5d305858d54317da729c5760976d491a.jpg" width="500px"><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-的包装类"><strong>Java 的包装类</strong><a aria-hidden="true" class="hash-link" href="#java-的包装类" title="Direct link to heading">​</a></h2><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<strong>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class）</strong>，int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span><strong>8 种包装类</strong></h5></div><div class="admonition-content"><p>8 种基本数据类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="装箱和拆箱是什么">装箱和拆箱是什么<a aria-hidden="true" class="hash-link" href="#装箱和拆箱是什么" title="Direct link to heading">​</a></h3><ul><li><strong>装箱</strong>：将基本类型用对应的引用类型包装起来。</li><li><strong>拆箱</strong>：将包装类型转换为对应的基本数据类型。</li></ul><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Integer x = 2;  // 装箱</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">int y = x;      // 拆箱</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>装箱过程是通过调用包装器的 valueOf() 方法实现的，而拆箱过程是通过调用包装器的 xxxValue() 方法实现的。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="包装类与常量池技术">包装类与常量池技术<a aria-hidden="true" class="hash-link" href="#包装类与常量池技术" title="Direct link to heading">​</a></h3><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>，即 Byte、Short、Integer、Long、Character、Boolean。前面 4 种包装类默认创建了数值 <!-- -->[ -128, 127 ]<!-- --> 的相应类型的缓存数据，Character 创建了数值在 <!-- -->[ 0 , 127 ]<!-- --> 范围的缓存数据，Boolean 直接返回 True 或者 False。如果超出对应范围仍然会去创建新的对象。</p><p>倘若你不理解这里的内容，也不用着急，安心往下看，马上就解决你的疑惑。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>为什么把缓存设置为 <!-- -->[ -128, 127 ]<!-- --> 区间，主要是考虑到性能和资源之间的权衡。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="equals-与包装类产生的奇妙化学反应">==、equals 与包装类产生的奇妙化学反应<a aria-hidden="true" class="hash-link" href="#equals-与包装类产生的奇妙化学反应" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Integer a = new Integer(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">Integer b = Integer.valueof(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">Integer c = 123;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">int d = 123;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这四种不同的 123 的赋值方式，它们之间的区别，是 Java 基础里比较重要的一个地方，接下来我会先从例子开始，再到源码，一点点的将它弄明白。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="integer-重写了-object-中的-equals-方法">Integer 重写了 Object 中的 equals 方法<a aria-hidden="true" class="hash-link" href="#integer-重写了-object-中的-equals-方法" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer a = new Integer(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer b = new Integer(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a == b);      // false</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a.equals(b)); // true</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这段程序的结果是什么呢？我想如果是对 Java 有一定的了解的同学应该知道答案，第一行是 false，第二行是 true。</p><p>不知道还记不记得本文最开头介绍 Object 类的时候，有介绍过 Object.eqauls(object)在比较什么，这个方法本质其实就是 ==，按道理来说 == 和 equals() 中应该是一样的结果，那么为什么此刻他们的结果不一样呢？</p><p>原因其实很简单，Object 类一切的始祖，所有的类都会继承 Object，Integer 继承了 Object 然后重写了 equals() 方法，重写后的 equals() 方法不再是比较两个变量的地址了，而是比较两个变量的值。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public boolean equals(Object obj) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (obj instanceof Integer) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return value == ((Integer)obj).intValue();</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="integer-中的常量池缓存">Integer 中的常量池缓存<a aria-hidden="true" class="hash-link" href="#integer-中的常量池缓存" title="Direct link to heading">​</a></h3><p>现在我们对上面的那个例子的代码稍作修改，改成使用 Integer.valueOf() 方法来创建对象。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer a = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer b = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a == b);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a.equals(b));</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>你会发现这里的结果发生了变化，两个结果都是 true，这说明 a 和 b 不仅仅只有值是相同的，甚至连所引用的 123 的地址都是一样的。为什么呢，这个就是刚才说到的常量池技术。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static Integer valueOf(int i) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    return new Integer(i);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">private static class IntegerCache {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    static final int low = -128;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    static final int high;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    static final Integer cache[];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        // high value may be configured by property</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        int h = 127;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        String integerCacheHighPropValue =</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        if (integerCacheHighPropValue != null) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">                int i = parseInt(integerCacheHighPropValue);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">                i = Math.max(i, 127);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">                // Maximum array size is Integer.MAX_VALUE</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            } catch( NumberFormatException nfe) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">                // If the property cannot be parsed into an int, ignore it.</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        high = h;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        cache = new Integer[(high - low) + 1];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        int j = low;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        for(int k = 0; k &lt; cache.length; k++)</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">            cache[k] = new Integer(j++);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        assert IntegerCache.high &gt;= 127;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    private IntegerCache() {}</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>我们打开源码来看一看，IntegerCache 是 Integer 类里面的一个静态类；valueOf() 方法的内容不多，很容易懂，就是如果调用了 valueOf()，会先判断一下在不在 IntegerCacghe.low 到 IntegerCache.high 的范围里面（这个范围就是<!-- -->[ -128, 127 ]<!-- -->），在的话就直接读缓存里的数据，不然就 new 一个 Integer 对象。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer a = Integer.valueOf(129);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer b = Integer.valueOf(129);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a == b);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a.equals(b));</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>所以当我们把 valueOf() 方法的参数变成 <!-- -->[ -128, 127 ]<!-- --> 外的数以后，第一行的结果就是 false 了。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="直接赋值是装箱的过程">直接赋值是装箱的过程<a aria-hidden="true" class="hash-link" href="#直接赋值是装箱的过程" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer a = 126;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer b = 126;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer c = 200;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer d = 200;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a == b);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(c == d);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这段代码的结果是 true 和 false，直接复制的时候，会将右侧的常量值自动装箱，本文之前有提到过，装箱的过程是调用 valueOf() 方法的过程。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="integer-拆箱后与-int-比较">Integer 拆箱后与 int 比较<a aria-hidden="true" class="hash-link" href="#integer-拆箱后与-int-比较" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Integer a = 129;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    int b = 129;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a == b);</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    System.out.println(a.equals(b));</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>想想这段代码的结果是什么，其实就两个可能性：一是 a 拆箱成 int 与 b 比较，拆箱以后就是 int == int，那么结果肯定是 true；二是 b 装箱成 Integer 与 a 比较，装箱以后就是 Integer == Integer，由于 129 在缓存区间外，所以结果肯定是 false。</p><p>实际上的结果是 true，也就是说 <strong>Integer 与 int 比较的结果，是 Integer 自动拆箱后在比较的结果。</strong></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="double-中的一些特别的常量">Double 中的一些特别的常量<a aria-hidden="true" class="hash-link" href="#double-中的一些特别的常量" title="Direct link to heading">​</a></h3><p>常量 Double.POSITIVE_INFINITY、 Double.NEGATIVEJNFINITY 、Double.NaN（以及相应的 Float 类型的常量）分别表示这三个特殊的值，但在实际应用中很少遇到。</p><p>特别要说明的是，不能这样检测一个特定值是否等于 Double.NaN。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">if (x == Double.NaN) // is never true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>所有<strong>非数值</strong>的值都认为是不相同的。然而，可以使用 Double.isNaN 方法。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">if (Double.isNaN(x)) // check whether x is not a number</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-的字符串"><strong>Java 的字符串</strong><a aria-hidden="true" class="hash-link" href="#java-的字符串" title="Direct link to heading">​</a></h2><p>Java 中的字符串是只读字符串，对它的任何操作，其实都是创建一个新的对象，然后将变量的引用指向该对象。这也被称作<strong>不可变</strong>。不可变的一个主要作用在于在多线程场景下，可以保证数据的一致性。</p><img src="/assets/images/字符串不可变-a39c5cb98420d7e69b5cbf3ad65d3785.jpg" width="500px"><p>Java 字符串的另一个特性是常量池优化，很上文我们提到的包装类常量池技术类似，当 String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象是，会直接返回缓存的引用。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>关于字符串常量池，以后会在<a href="/Java/初探/初探 Java 虚拟机">初探 Java 虚拟机</a>一文中在做介绍。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="string-的最大长度其实是有限的">String 的最大长度其实是有限的<a aria-hidden="true" class="hash-link" href="#string-的最大长度其实是有限的" title="Direct link to heading">​</a></h3><p>首先要明白 String 本身从逻辑概念上来说是没有最大长度限制的，但是需要知道的是，String 类内部是使用 char 数组或者 byte 数组来存储数据的，而 Java 中的数组其实是引用对象，本身有一个 length 属性（注意是 length 属性，而不是 length() 方法）。也就是说 String.length() 方法的具体实现其实就是返回了 value.length。</p><p>因为数组的 length 属性是一个 int 类型的变量，而 int 本身是由长度限制的，所以 String 在实际实现上允许的最大长度就是 2^32 - 1 = 2147483647。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>实际上这个值也不太对，因为 Java 虚拟机会为数组的对象头保留一些空间，所以实际上还要在小一些，通常要再小 8 个字节。</p></div></div><p>但是这个说法是仅仅针对字符串变量而言，如果是写在代码中的字面量，那么允许的最大长度取决于字符串在常量池中的存储大小，也就是字符串在 class 格式文件中的存储格式。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">CONSTANT_Utf8_info {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    u1 tag;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    u2 length;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    u1 bytes[length];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>u2 是无符号的 16 位整数，因此理论上允许的字面量的最大长度是 2^16 - 1 = 65535。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>然而实际测试表明，使用 javac 编译时允许的最大长度仅为 65534，超过就编译错误。</p></div></div><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String str = &quot;xxxx...xxx&quot;;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>也就是说 str 的最大长度是 2147483647，而写在代码中的，双引号中的内容最大长度是 65534。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="string-类为什么是不可变的">String 类为什么是不可变的<a aria-hidden="true" class="hash-link" href="#string-类为什么是不可变的" title="Direct link to heading">​</a></h3><p>从 Java 8 和 Java 9 以后两个版本的源码来看。</p><p>在 Java 8 中，String 内部使用了 char 数组存储数据。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public final class String</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // The value is used for character storage.</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    private final char value[];</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在 Java 9 后，String 内部的实现改用 byte 数组存储字符串，同时使用了一个 名字叫做 coder 的 byte 类型变量作为标识，来表示使用了哪种编码。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // The value is used for character storage.</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    private final byte[] value;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // The identifier of the encoding used to encode the bytes in {@code value}</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    private final byte coder;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>有两个地方是我们要注意的：一个是保存值的 value 数组被声明为 final，这意味着 value 数组在初始化之后就不能再引用其它数组，并且 String 内部也没有改变 value 数组的方法，这也就是保证 String 不可变的方式；二是要注意 String 类本身也是一个 final 类型的类，表示 String 类不能被继承，可以提高系统的安全性。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="string-不可变是内容不可变">String 不可变是内容不可变<a aria-hidden="true" class="hash-link" href="#string-不可变是内容不可变" title="Direct link to heading">​</a></h3><p>String 不可变指的是所指向的引用中的内容不可变，引用本身却是可以变的。</p><div class="codeBlockContainer_J+bg language-java"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">String str = &quot;Hello&quot;;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">str = str + &quot; World&quot;;</span><br></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">System.out.println(&quot;str =&quot; + str);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>实际上，原来 String 的内容是不变的（也就是&quot;Hello&quot;这个字符串本身），只是 str 这个变量由原来指向 &quot;Hello&quot; 的内存地址转为指向 &quot;Hello World&quot; 的内存地址而已，也就是说多开辟了一块内存区域给 &quot;Hello World&quot; 字符串。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="string-类不可变带来了什么好处">String 类不可变带来了什么好处<a aria-hidden="true" class="hash-link" href="#string-类不可变带来了什么好处" title="Direct link to heading">​</a></h3><p>第一是可以缓存 hash 值，因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p>第二是 String Pool 的需要，如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p>第三是安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p>第四是线程安全，String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="stringintern到底是干嘛的">String.intern()到底是干嘛的<a aria-hidden="true" class="hash-link" href="#stringintern到底是干嘛的" title="Direct link to heading">​</a></h3><p>可以使用 String 的 intern 方法在运行过程将字符串添加到字符串常量池中。</p><p>当一个字符串对象调用 intern 方法时，如果字符串常量池中已经存在一个字符串和该字符串<strong>值相等</strong>（使用 equals 方法进行确定），那么就会返回字符串常量池中字符串的引用；否则就会在 字符串常量池中添加一个新的字符串，并返回这个新字符串的引用。</p><img src="/assets/images/String中的intern方法-179b29b7906ce1da1e765fda2b6e4996.jpg" width="500px"><p>如果是采用字面量直接赋值的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><img src="/assets/images/String的字面量会直接进入常量池-cbd43ab0c8391892da12d4ae6f55b155.jpg" width="500px"><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span><strong>字符串常量池</strong></h5></div><div class="admonition-content"><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="stringstringbufferstringbuilder-的区别">String、StringBuffer、StringBuilder 的区别<a aria-hidden="true" class="hash-link" href="#stringstringbufferstringbuilder-的区别" title="Direct link to heading">​</a></h3><p>第一是可变性，String 类中使用被 final 声明的字符数组保存字符串，所以 String 对象是不可变的。StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，这两种对象都是可变的。</p><p>然后是线程安全性，String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p>最后是性能，每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10% ~ 15% 左右的性能提升，但却要冒多线程不安全的风险。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Java/导航"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->导航</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Java/初探/初探 Java 面向对象"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">初探 Java 面向对象<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java-的基本概念" class="table-of-contents__link toc-highlight"><strong>Java 的基本概念</strong></a><ul><li><a href="#jvmjdkjre-都是些什么" class="table-of-contents__link toc-highlight">JVM，JDK，JRE 都是些什么</a></li><li><a href="#为什么说-java-语言是编译与解释共存" class="table-of-contents__link toc-highlight">为什么说 Java 语言是“编译与解释共存”</a></li><li><a href="#object-类是一切的始祖" class="table-of-contents__link toc-highlight">Object 类是一切的始祖</a></li><li><a href="#objectequalsobject-obj-在比较什么" class="table-of-contents__link toc-highlight">Object.equals(Object obj) 在比较什么</a></li><li><a href="#objecthashcode-用来计算散列码" class="table-of-contents__link toc-highlight">Object.hashCode() 用来计算散列码</a></li><li><a href="#equals-和-hashcode-的关系" class="table-of-contents__link toc-highlight">equals() 和 hashCode() 的关系</a></li><li><a href="#-和-equals-的关系" class="table-of-contents__link toc-highlight">== 和 equals() 的关系</a></li><li><a href="#-和--的区别" class="table-of-contents__link toc-highlight">&amp; 和 &amp;&amp; 的区别</a></li><li><a href="#switch-的操作数可以是字符串不能是-long-和-浮点数" class="table-of-contents__link toc-highlight">switch 的操作数可以是字符串，不能是 long 和 浮点数</a></li></ul></li><li><a href="#java-的基本数据类型" class="table-of-contents__link toc-highlight"><strong>Java 的基本数据类型</strong></a><ul><li><a href="#java-没有无符号整数" class="table-of-contents__link toc-highlight">Java 没有无符号整数</a></li><li><a href="#定义-short-s--1那么-s--s--1-和-s--1-的不同" class="table-of-contents__link toc-highlight">定义 short s = 1，那么 s = s + 1 和 s += 1 的不同</a></li><li><a href="#boolean-的大小是多少" class="table-of-contents__link toc-highlight">boolean 的大小是多少</a></li><li><a href="#float-f--34是否是正确的" class="table-of-contents__link toc-highlight">float f = 3.4，是否是正确的</a></li><li><a href="#u0022u0022u0022分别会打印什么" class="table-of-contents__link toc-highlight"><code>&quot;"&quot;</code>、<code>&quot;"+"&quot;</code>，分别会打印什么</a></li></ul></li><li><a href="#java-的包装类" class="table-of-contents__link toc-highlight"><strong>Java 的包装类</strong></a><ul><li><a href="#装箱和拆箱是什么" class="table-of-contents__link toc-highlight">装箱和拆箱是什么</a></li><li><a href="#包装类与常量池技术" class="table-of-contents__link toc-highlight">包装类与常量池技术</a></li><li><a href="#equals-与包装类产生的奇妙化学反应" class="table-of-contents__link toc-highlight">==、equals 与包装类产生的奇妙化学反应</a></li><li><a href="#integer-重写了-object-中的-equals-方法" class="table-of-contents__link toc-highlight">Integer 重写了 Object 中的 equals 方法</a></li><li><a href="#integer-中的常量池缓存" class="table-of-contents__link toc-highlight">Integer 中的常量池缓存</a></li><li><a href="#直接赋值是装箱的过程" class="table-of-contents__link toc-highlight">直接赋值是装箱的过程</a></li><li><a href="#integer-拆箱后与-int-比较" class="table-of-contents__link toc-highlight">Integer 拆箱后与 int 比较</a></li><li><a href="#double-中的一些特别的常量" class="table-of-contents__link toc-highlight">Double 中的一些特别的常量</a></li></ul></li><li><a href="#java-的字符串" class="table-of-contents__link toc-highlight"><strong>Java 的字符串</strong></a><ul><li><a href="#string-的最大长度其实是有限的" class="table-of-contents__link toc-highlight">String 的最大长度其实是有限的</a></li><li><a href="#string-类为什么是不可变的" class="table-of-contents__link toc-highlight">String 类为什么是不可变的</a></li><li><a href="#string-不可变是内容不可变" class="table-of-contents__link toc-highlight">String 不可变是内容不可变</a></li><li><a href="#string-类不可变带来了什么好处" class="table-of-contents__link toc-highlight">String 类不可变带来了什么好处</a></li><li><a href="#stringintern到底是干嘛的" class="table-of-contents__link toc-highlight">String.intern()到底是干嘛的</a></li><li><a href="#stringstringbufferstringbuilder-的区别" class="table-of-contents__link toc-highlight">String、StringBuffer、StringBuilder 的区别</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Txiz</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4f9b11ed.js"></script>
<script src="/assets/js/main.83634378.js"></script>
</body>
</html>